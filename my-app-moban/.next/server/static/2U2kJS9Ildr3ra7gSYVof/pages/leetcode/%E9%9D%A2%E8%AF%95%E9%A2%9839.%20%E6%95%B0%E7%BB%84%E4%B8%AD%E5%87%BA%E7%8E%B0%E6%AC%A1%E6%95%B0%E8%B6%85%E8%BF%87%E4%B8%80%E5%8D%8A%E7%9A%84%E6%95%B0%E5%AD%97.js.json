{"pageProps":{"post":{"date":"2021 / 3 / 1","slug":"面试题39. 数组中出现次数超过一半的数字.js","content":"<pre> <code class=\"hljs\" ><span class=\"hljs-comment\">/**\n 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n 你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n 示例 1:\n\n 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]  1 2 2 2 2 2 3 4 5\n 输出: 2\n  \n\n 限制：\n\n 1 &lt;= 数组长度 &lt;= 50000\n 注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/\n 来源：力扣（LeetCode）\n 链接：https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof\n 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n */</span>\n<span class=\"hljs-comment\">/*\n思路1：有一个数字出现的次数超过数组长度的一半，那么无论怎么排序，最后在数组中间位置的那个数一定就是那个数\n */</span>\n<span class=\"hljs-comment\">/**\n * @param {number[]} nums\n * @return {number}\n */</span>\n\n<span class=\"hljs-built_in\">var</span> majorityElement = function (nums) {\n    <span class=\"hljs-keyword\">if</span> (nums.<span class=\"hljs-built_in\">length</span> === <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-built_in\">return</span> <span class=\"hljs-number\">0</span>\n    }\n\n    maopaoSort(nums)\n    <span class=\"hljs-built_in\">return</span> nums[Math.<span class=\"hljs-built_in\">floor</span>(nums.<span class=\"hljs-built_in\">length</span> / <span class=\"hljs-number\">2</span>)]\n};\n\nfunction maopaoSort(nums) {\n    <span class=\"hljs-built_in\">let</span> tag = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">length</span>; i++) {\n        tag = <span class=\"hljs-literal\">false</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; nums.<span class=\"hljs-built_in\">length</span> - i - <span class=\"hljs-number\">1</span>; j++) {\n            <span class=\"hljs-keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"hljs-number\">1</span>]) {\n                tag = <span class=\"hljs-literal\">true</span>\n                changeTwo(nums, j, j + <span class=\"hljs-number\">1</span>)\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (!tag) {  // 说明这一轮没有发生交换，就不必再继续比较了\n            <span class=\"hljs-built_in\">break</span>;\n        }\n    }\n}\n\nfunction changeTwo(nums, i, j) {\n    <span class=\"hljs-built_in\">let</span> _temp = nums[i]\n    nums[i] = nums[j]\n    nums[j] = _temp\n}\n\n<span class=\"hljs-built_in\">let</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>]\n// console.<span class=\"hljs-built_in\">log</span>(majorityElement(nums))\n\n<span class=\"hljs-comment\">/*\n思路2： 使用Map 存储相同的数字各自出现几次，最后在map中挑出次数大于1/2的那个\n */</span>\n\n<span class=\"hljs-built_in\">let</span> majorityElement2 = (nums) =&gt; {\n    <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">map</span> = <span class=\"hljs-built_in\">new</span> Map()\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">length</span>; i++) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">map</span>.<span class=\"hljs-built_in\">get</span>(nums[i])) {\n            <span class=\"hljs-built_in\">map</span>.set(nums[i], <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-built_in\">get</span>(nums[i]) + <span class=\"hljs-number\">1</span>)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-built_in\">map</span>.set(nums[i], <span class=\"hljs-number\">1</span>)\n        }\n    }\n    <span class=\"hljs-built_in\">let</span> half_num = nums.<span class=\"hljs-built_in\">length</span> / <span class=\"hljs-number\">2</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> [<span class=\"hljs-built_in\">key</span>, value] of <span class=\"hljs-built_in\">map</span>.entries()) {\n        <span class=\"hljs-keyword\">if</span> (value &gt; half_num) {\n            <span class=\"hljs-built_in\">return</span> <span class=\"hljs-built_in\">key</span>\n        }\n    }\n    <span class=\"hljs-built_in\">return</span> <span class=\"hljs-number\">0</span>\n}\n\n// console.<span class=\"hljs-built_in\">log</span>(majorityElement2([]))\n\n<span class=\"hljs-comment\">/*\n思路3： 摩尔投票法\n每一次迭代，默认当前第一个数是众数，然后相抵消，一旦和为0，则进行下一轮的迭代\n */</span>\n\n<span class=\"hljs-built_in\">let</span> majorityElement3 = (nums) =&gt; {\n    <span class=\"hljs-keyword\">if</span>(nums.<span class=\"hljs-built_in\">length</span> ===<span class=\"hljs-number\">0</span>) <span class=\"hljs-built_in\">return</span> <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-built_in\">let</span> x = nums[<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-built_in\">let</span> <span class=\"hljs-built_in\">sum</span> = <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt; nums.<span class=\"hljs-built_in\">length</span>; i++) {\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">sum</span> === <span class=\"hljs-number\">0</span>){\n            x = nums[i]\n        }\n        <span class=\"hljs-keyword\">if</span>(nums[i] === x){\n            <span class=\"hljs-built_in\">sum</span> +=<span class=\"hljs-number\">1</span>\n        }<span class=\"hljs-keyword\">else</span>{\n            <span class=\"hljs-built_in\">sum</span> -=<span class=\"hljs-number\">1</span>\n        }\n    }\n    <span class=\"hljs-built_in\">return</span> x\n}\n\nconsole.<span class=\"hljs-built_in\">log</span>(majorityElement3([]))\n</code> </pre>"}},"__N_SSG":true}